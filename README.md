# forgeops-init

## Note

If you are using this with the 5.0.0 release as documented in the DevOps guide, make sure you are on the correct branch:

`git checkout release/5.0.0`


## About

This repository contains an initial skeleton configuration for the ForgeRock Identity platform on Kubernetes.
This is used in conjunction with the [forgeops](https://stash.forgerock.org/projects/CLOUD/repos/forgeops) repository. 
The files in this directory are (mostly) auto-generated by exporting configuration.

You can fork and clone this project to use as starting point. 

These configuration files are mounted as a volume by Kubernetes. This
 is done at runtime by cloning the git repository in an init container to make the configuration available
 to the product containers. 
 
Other configuration strategies are possible, and include:

* On Minikube, map a local configuration folder on your workstation to a hostPath volume in Kubernetes.
* To create immutable style docker containers, clone this configuration and copy the files into the container
as part of the build process.
 

## Project Layout 

The layout presented here is an example of how you might organize your configuration. The basic
idea is that configurations are organized by environments (dev, qa, production, prod_east, prod_west, etc.)

The directory structure is:   `/{environment}/{component}/{project}/* `

Where:
* environment is one of default, dev,qa, prod, etc. Environment names may be mapped to Kubernetes namespaces. It
is recommended they are short, lower case, and avoid any non alphanumeric characters. The "default" environment
is a common Kubernetes namespace used on Minikube. This is the recommended folder for out of box deployment.
* component is one of: am, dj, ig, idm
* project - is a specific configuration for that component. For example, "my-test-config", "current", "canary".
These names may be also be mapped as part of the environment, so it is best is to avoid special characters
other than '-'. 


Nested underneath the project folder are the configuration files for the component. For example, json files exported by OpenIDM or 
by amster. 

In addition, the following top-level directories are available:

* bin/  holds utility scripts that are useful for managing configuration files. In the future this may include scripts 
 to auto-migrate configuration from one environment to another.
* common/{component}  Holds any configuration files which are 100% common to all environments. 


## Migration

Migration from one environment to another (for example from dev to QA to prod) is done manually by
copying files from one environment to another and adjusting those files as required (for example,
replacing dev server names with QA).  You may wish to use additional tools or scripts to help automate this
process.


A sample workflow that you might implement:

* A feature is developed in the default or dev environment, and exported/saved to the {project} folder.
* The feature and/or the entire configuration is copied to the next environment. This can be scripted and 
 triggered by a git commit hook. The
 scripts can copy files and perform environment specific search and replace. 
* If a feature is consistent in all environments, it can be exported to common/{component}. You would
merge the features in common/ into the target environment.
* The resulting merged configuration is committed to git. Automated CI/CD tools may run checks on this
commit to validate the configuration is functional. 




